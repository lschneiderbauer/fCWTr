#' Fast continuous wavelet transform
#'
#' The core function of this package making use of the fCWT library. It processes
#' an input signal in form of a real valued numeric vector interpreted as an
#' evenly spaced time series and returns the absolute values of a spectogram,
#' i.e. a graph with a time and a frequency dimension.
#'
#' @details
#' The wavelet used in this calculation is the so called Morlet wavelet,
#' a sinusoidal wave modulated by a Gaussian whose spread is controlled by
#' the argument `sigma`.
#'
#' See the original paper
#' Arts, L.P.A., van den Broek, E.L.
#' The fast continuous wavelet transformation (fCWT) for real-time, high-quality,
#' noise-resistant time–frequency analysis.
#' Nat Comput Sci 2, 47–58 (2022). \doi{10.1038/s43588-021-00183-z}
#'
#' @param x
#'  Real-valued time series. The time steps are assumed to be evenly spaced.
#'
#' @param x_sample_freq
#'  Sampling rate of input time series `x`. This number primarily establishes
#'  a connection to physical units which is used in other frequency definitions
#'  as well as the units of the output data. Expects either a value with frequency
#'  units, generated with [u()], or a pure number, in which case it is
#'  interpreted in units of 'Hertz'.
#'
#' @param y_sample_freq
#'  Sampling rate of output time series. This defaults to the input sampling
#'  rate `x_sample_freq`, but can be reduced if a lower resolution output
#'  signal is required (saves memory).
#'
#' @param n_freqs
#'  Number of frequency bins generated by the CWT. The frequencies
#'  are linearly or logarithmically distributed, depending on the `freq_scale`
#'  argument. Computation time increases when raising the
#'  number of frequency bins.
#'
#' @param freq_begin,freq_end
#'  Optionally specifies the frequency range `[freq_end, freq_begin]`. If not
#'  specified the maximal meaningful frequency range, depending on the input signal,
#'  is taken.
#'  A frequency-valued number, generated with [u()], or a pure number, that is
#'  interpreted in units of 'Hertz'.
#'
#' @param freq_scale ( `"freq"` | `"log"` )
#' Should the frequency scale be linear or logarithmic?
#'  "linear"  / "log" for linear / logarithmic.
#' The default scale is logarithmic, since frequency resolution decreases
#' with increasing frequency and a linear scale contains superficial information.
#'
#' @param sigma
#'  Sets a dimensionless parameter \eqn{\Sigma} controlling the wavelet spread.
#'  Changing this parameter adjusts the time/frequency uncertainty balance,
#'  \eqn{\Delta t = 4 \frac{\Sigma}{f}}, \eqn{\Delta f = 4 \frac{f}{2\pi \Sigma}}.
#'  Larger (lower) value of sigma corresponds to a better (worse) frequency
#'  resolution and a worse (better) time resolution.
#'
#'  For more information, see \code{vignette("sigma", package = "fCWTr")}).
#'
#'  Defaults to \eqn{2\pi}. Note that there is not really a natural choice for
#'  sigma, it depends on the use case. So the default choice can very well be
#'  quite a bad choice (it probably is for audio data).
#'
#' @param remove_coi ( [TRUE] | [FALSE] )
#'  Boundary effects can result in nonphysical artifacts. If `remove_coi = TRUE`,
#'  those are effectively removed by setting corresponding values to [NA].
#'  We define the essential support of the
#'  (Gaussian) wavelet to be four times its standard deviation,
#'  \eqn{\Delta t = \frac{\sigma}{f}}, and so a wavelet touches
#'  the boundary if the distance of the center of the wavelet to the boundary
#'  is less then \eqn{\Delta t /2}. Values that fall into that range are removed
#'  if `remove_coi = TRUE`.
#'
#' @param n_threads
#'  Number of threads used by the computation, if supported by your platform.
#'  Defaults to 2 threads (to accommodate CRAN requirements).
#'  If [openmp_enabled()] returns `FALSE`, this argument is ignored, and
#'  only a single thread is used.
#'
#' @return
#'  The spectogram, a numeric real-valued matrix with dimensions
#'  `dim = c(length(x), n_freqs)`, curated with some additional properties.
#'  This matrix is wrapped into a S3-class `fcwtr_scalogram` so that plotting and
#'  coercion functions can be used conveniently. Use [as.matrix()] to strip
#'  the curated information. Or use [as.data.frame()] to convert to another
#'  data format.
#'
#' @seealso [fcwt_batch()]
#'
#' @examples
#' ts_sin_440 <- sin((1:5000) * 2 * pi * 440 / 44100)
#'
#' fcwt(
#'   ts_sin_440,
#'   x_sample_freq = u(44.1, "kHz"),
#'   freq_begin = u(50, "Hz"),
#'   freq_end = u(1000, "Hz"),
#'   n_freqs = 10,
#'   sigma = 5
#' )
#' @export
fcwt <- function(x,
                 x_sample_freq,
                 y_sample_freq = x_sample_freq,
                 n_freqs,
                 freq_begin = 2 * x_sample_freq / length(x),
                 freq_end = x_sample_freq / 2,
                 freq_scale = c("log", "linear"),
                 sigma = 2 * pi,
                 # abs = FALSE,
                 remove_coi = TRUE,
                 n_threads = 2L) {
  stopifnot(is.numeric(x))
  stopifnot(is.numeric(freq_end), freq_end > freq_begin)
  stopifnot(is.numeric(n_freqs), n_freqs > 0)
  stopifnot(is.numeric(sigma), sigma > 0)
  stopifnot(is.numeric(n_threads))


  x_sample_freq <- as_freq(x_sample_freq)
  y_sample_freq <- as_freq(y_sample_freq)
  freq_begin <- as_freq(freq_begin)
  freq_end <- as_freq(freq_end)
  stopifnot(x_sample_freq > u(0, "Hz"))
  stopifnot(
    y_sample_freq > u(0, "Hz"),
    y_sample_freq <= x_sample_freq
  )
  stopifnot(freq_begin > u(0, "Hz"))

  freq_scale <- match.arg(freq_scale)

  freq_scale_lgl <- (freq_scale == "linear")
  stopifnot(isTRUE(freq_scale_lgl) || isFALSE(freq_scale_lgl))

  # we expect the numbers in Hz here
  output <-
    fcwt_raw(
      as.numeric(x), as.integer(hz(x_sample_freq)),
      hz(freq_begin), hz(freq_end),
      as.integer(n_freqs), sigma, as.integer(n_threads),
      freq_scale_lgl,
      FALSE,
      abs = TRUE
    )

  # if (!abs) {
  #   dim(output) <- c(length(signal), n_freqs, 2)
  #
  #   output <- output[, , 1] + output[, , 2] * 1i
  # } else {
  dim(output) <- c(length(x), n_freqs)
  # }

  sc <-
    fcwtr_scalogram(
      output,
      time_offset = u(0, "s"), x_sample_freq, freq_begin, freq_end,
      freq_scale, sigma
    ) |>
    sc_agg(wnd_from_target_sample_freq(y_sample_freq, x_sample_freq))

  if (remove_coi) {
    sc_set_coi_na(sc)
  } else {
    sc
  }
}
