# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Wraps CPP cwt function (computing a continuous wavelet transform)
#'
#' @param input        A numeric vector representing the time series
#' @param startoctave  Starting octave (corresponds to a scale of 2^startoctave)
#' @param noctaves     Number of octaves to compute
#' @param nsuboctaves  Computing steps per octave
#' @param sigma        Parameter controlling time-frequency precision
#' @param nthreads     Number of threads to use (FFTW)
#' @param optplans     Use FFTW optimization plans
#' @param abs          Returns the absolute values instead of full
#'                     complex representations.
#' @return Returns a numeric vector containing CWT information.
#'
fcwt_raw <- function(input, startoctave, noctaves, nsuboctaves, sigma, nthreads, optplans, abs) {
    .Call('_fcwtr_fcwt_raw', PACKAGE = 'fcwtr', input, startoctave, noctaves, nsuboctaves, sigma, nthreads, optplans, abs)
}

#' Wraps CPP 'create_optimization_schemes' function
#'
#' FFTW allows one to create optimization plans in advance,
#' which can help to speed up individual calls of [fcwt_raw].
#'
#' @param max_size  Typical length of input vector
#' @param nthreads  Number of threads used in the computation
#' @param flag
#' From https://www.fftw.org/fftw3_doc/Planner-Flags.html:
#' "estimate"" specifies that, instead of actual measurements of different algorithms, a simple heuristic is used to pick a (probably sub-optimal) plan quickly. With this flag, the input/output arrays are not overwritten during planning.
#' "measure"" tells FFTW to find an optimized plan by actually computing several FFTs and measuring their execution time. Depending on your machine, this can take some time (often a few seconds). FFTW_MEASURE is the default planning option.
#' "patient"" is like FFTW_MEASURE, but considers a wider range of algorithms and often produces a “more optimal” plan (especially for large transforms), but at the expense of several times longer planning time (especially for large transforms).
#' "exhaustive" is like FFTW_PATIENT, but considers an even wider range of algorithms, including many that we think are unlikely to be fast, to produce the most optimal plan but with a substantially increased planning time.
#' "wisdom_only" is a special planning mode in which the plan is only created if wisdom is available for the given problem, and otherwise a NULL plan is returned. This can be combined with other flags, e.g. ‘FFTW_WISDOM_ONLY | FFTW_PATIENT’ creates a plan only if wisdom is available that was created in FFTW_PATIENT or FFTW_EXHAUSTIVE mode. The FFTW_WISDOM_ONLY flag is intended for users who need to detect whether wisdom is available; for example, if wisdom is not available one may wish to allocate new arrays for planning so that user data is not overwritten.
#'
create_opt_schemes_raw <- function(max_size, nthreads, flag) {
    invisible(.Call('_fcwtr_create_opt_schemes_raw', PACKAGE = 'fcwtr', max_size, nthreads, flag))
}

