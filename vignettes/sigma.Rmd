---
title: "Controlling the wavelet spread"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Controlling the wavelet spread}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The continuous wavelet transform (CWT) essentially evaluates a correlation function of the input signal with shifted and scaled Morlet wavelets. A Morlet wavelet is a sinusoidal wave packet modulated by a Gaussian envelope. The spread of Gaussian envelope is what controls the time/frequency balance of the FCWT result.

In contrast to the [Short Time Fourier Transform](https://en.wikipedia.org/wiki/Short-time_Fourier_transform), where the window size does not depend on the frequency, the CWT models a frequency-dependent window size by the frequency depending spread of the Gaussian envelope.[^1]

[^1]: That is of course one of the selling points of the CWT: it works for all frequency ranges, while the fixed window size in the Short Time Fourier Transform will break down when probing modes whose wavelength approach the window size, at the same time it lacks a reasonable time resolutions for modes whose wavelength is much smaller than the window size.

For a particular time $t$ and a reference frequency $f$, the Gaussian envelope $g(t, f)$ of the wavelet is given by $$g(t, f) \sim e^{-\left( \frac{t f}{2 \sigma} \right)^2}$$ with variance in time $\Delta t=\frac{\sigma}{f}$ which also sets the scale for the effective time resolution of the CWT at frequency $f$. The corresponding frequency resolution is given by the spreading of the Gaussian envelope in Fourier space: $\Delta f = \frac{f}{2\pi \sigma}$. The time and frequency resolution satisfy the famous time-frequency uncertainty relation $\Delta t \Delta f=\frac{1}{2\pi}$.

The time-frequency uncertainty relation is always true, but we can adjust the parameter $\sigma$ to increase (decrease) time resolution at the cost of decreasing (increasing) the frequency resolution. The "correct" balance depends on your use case.

### Example: Piano keys

Let's try to understand the meaning of $\sigma$ via an example: We would like to analyse piano music, and be able to at least distinguish different piano key frequencies.

We can for example check what the resolutions corresponding to $\sigma=1$ at the key A4 (440 Hz) is with helper functions that implement the formulas above:

```{r setup}
library(fCWTr)
```

```{r}
sigma_resolution(sigma = 1, u(440, "Hz"))
```

We see now, with $\sigma=1$, our frequency resolution at 440 Hz is only 70 Hz! The spreading is way too high to be able to distinguish different keys (the next key A#4 is at 466 Hz and the previous key Ab4 is at 415 Hz), we need to able at least to resolve the difference, 15 Hz. Let's be sure and make it half of that, 7 Hz. We can use another helper function to check what the corresponding $\sigma$ should be:

```{r}
sigma_from_frequency_resolution(u(7, "Hz"), u(440, "Hz"))
```

and it tells us we need $\sigma=10$ or higher. Let's double-check what that implies for the time resolution:

```{r}
sigma_resolution(sigma = 10, u(440, "Hz"))
```

That means, we can detect those frequencies with a time resolution of 22 milliseconds. A typical very fast piano beat is around 180 beats per minutes (\> Prestissimo), that means, 3 beats per seconds, and the required time resolution to detect that is at least 330 milliseconds: we have no problems doing that with $\sigma =10$, and even have some leeway.

Let's compare these two settings in practice:

#### Sigma = 1

```{r}
library(ggplot2)

fcwt_batch(
  ts_piano_sample,
  sample_freq = u(44.1, "kHz") / 4,
  freq_begin = u(220, "Hz"),
  freq_end = u(440, "Hz") * 4,
  # 5 octaves, 12 keys per octave, 3 frequencies per key
  n_freqs = 12 * 5 * 3,
  sigma = 1,
  freq_scale = "log",
  time_resolution = u(100, "ms")
) |>
  plot()
```

#### Sigma = 10

```{r}
library(ggplot2)

fcwt_batch(
  ts_piano_sample,
  sample_freq = u(44.1, "kHz") / 4,
  freq_begin = u(220, "Hz"),
  freq_end = u(440, "Hz") * 4,
  # 5 octaves, 12 keys per octave, 3 frequencies per key
  n_freqs = 12 * 5 * 3,
  sigma = 10,
  freq_scale = "log",
  time_resolution = u(100, "ms")
) |>
  plot()
```

#### Sigma = 20

```{r}
fcwt_batch(
  ts_piano_sample,
  sample_freq = u(44.1, "kHz") / 4,
  freq_begin = u(220, "Hz"),
  freq_end = u(440, "Hz") * 4,
  # 5 octaves, 12 keys per octave, 3 frequencies per key
  n_freqs = 12 * 5 * 3,
  sigma = 20,
  freq_scale = "log",
  time_resolution = u(100, "ms")
) |>
  plot()
```

In some way, $\sigma$ can be thought of the exposure time of a camera that has to adjusted manually. Is the exposure time too long the picture becomes blurry, is it too short, the picture becomes too dark to see anything. A good balance is the key to a good picture.
